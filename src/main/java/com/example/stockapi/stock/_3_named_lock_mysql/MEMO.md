#named_lock

### GET_LOCK()
get_lock(_'string'_, second) 은  'string' 에 해당하는 이름을 가지고 데이터베이스 락을 획득한다.
get_lock() 으로 락을 잡은 세션 외에 다른 세션에서 락을 잡으려는 요청은 블락된다.
싱글 mysqld 에서 동작하기 때문에 여러 DB 에서 락을 공유할 순 없다.

애플리케이션 락을 구현하기 위해 사용할 수 있다. (이것이 Pessimestic Lock 과 차이)

락을 풀땐 release_lock()을 이용한다.
commit 이나 roll back에 의해서 락을 잡거나 풀지 않는다. 오직 get_lock() 으로 락을 획득하고 release_lock() 으로 락을 푼다. (release_all_locks()도 있긴 하다.)
락을 풀땐, 락을 잡은 세션만 락을 풀 수 있다.


**Pessimistic Lock(비관적 락) 과의 차이가 무엇인가?**
비관적 락은 데이터베이스의 레코드에 직접 락을 거는 것이다. 그렇게되면 락을 획득하기 위해 대기할 때, 획득할 때 까지 DB 커넥션을 물고있어야 한다. 애플리케이션 쓰레드1 -> DB 커넥션1 , 관련없는 다른 작업들도 DB 커넥션이 부족해져 전체성능에 영향을 미친다.
하지만 네임드 락은 커넥션 풀을 분리할 수 있다. 락을 잡아야하는 작업만 락 커넥션풀을 이용하므로 병목되는 기능을 제한할 수 있다.

그러나 단점은 락을 잘 관리해주기 위해 구현이 어렵다는 점이다. 락을 잡은 세션만 락을 해제할 수 있어서 커넥션 관리를 잘해야 한다.
예를들어 커넥션풀을 사용하면 커넥션을 재사용하게 되서 서로 다른 요청임에도 락을 잡은 커넥션과 어떤 요청이 같은 커넥션을 공유할 수 있다. 이 경우 새로운 요청이 블록되지 않는 문제가 있다.
테스트를 위해 풀 사이즈를 1로 조절해보면 알 수 있다. 